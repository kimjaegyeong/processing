#  컴퓨터그래픽스  
### 원을 변화시키는 스마트폰 앱
##### 작성자: 20191115 곽희진, 20191121 김재경 

---------------------
### 2. 요약  


저희 6팀은 스마트폰으로 프로세싱 속 원의 이동과 색을 조종하는 앱을 만들었습니다.  
앱 인벤터를 이용하여 만은 앱을 사용하여 공이 나아가는 방향, 공의 색깔을 지정하면 
프로세싱의 실행화면에서 사용자가 입력한 값 대로 공의 상태가 변화합니다.   
 프로세싱이 스마트폰에서 와이파이를 통하여 보낸 값인 0,1,2,3을 받으면 각각 상, 하, 좌, 우로 반응하고, 4, 5, 6, 7, 8, 9, 10, 11의 값을 읽으면 각각 빨, 주, 노, 초, 파, 남, 보, 흰색이 공의 색깔로 지정됩니다.  

--------------------
### 3. 내용
앱 인벤터 블록 코딩 


우선, 사용자가 원하는 방향대로 원이 움직일 수 있도록 Button.Click 블록을 만들었습니다.  
그리고, do 부분에 Web 컴포넌트에 소속된 블록을 추가합니다. Web컴포넌트 블록은 사용자가 원하는 정보를 와이파이를 통해 프로세싱으로 전달해줍니다.  
do 부분에 이 블록을 넣으면, 사용자가 button을 클릭했을 때, do 안의 블록이 실행됩니다.  이 프로그램에서는 Web1.PutText를 사용하여 text에 저장된 값을 프로세싱으로 넘기도록 했습니다.  
원이 이동하는 상하좌우는 0에서 3까지 코딩하고, 빨, 주, 노, 초, 파, 남, 보, 흰색으로 원의 색을 바꾸는 것은 4에서 11번으로 코딩하였습니다.    

아래는 프로세싱 코드입니다.  
```
PImage img;
import processing.net.*;
Server s;
Client c;
int a,b;
int x=0;
int y=0;
void setup(){
s=new Server(this,1234);
size(600,600);
img = loadImage("rainbow.png");

}
void draw(){

c=s.available();

if(c!=null){
 image(img, 300, 300, width, height);

ellipse(a,b,80,80);
String m=c.readString();
m=m.substring(m.length()-1);
if(m.equals("0")) b=b-30-y; if(b<0||b>600) {b=0; a=0;} 
if(m.equals("1")) b=b+30+y; if(b<0||b>600) {b=0; a=0;}
if(m.equals("2")) a=a-30-x; if(a<0||a>600) {a=0; b=0;}
if(m.equals("3"))  a=a+30+x; if(a<0|| a>600) {a=0; b=0;}
if(m.equals("4")) fill(153,0,0);
if(m.equals("5")) fill(255,153,0);
if(m.equals("6")) fill(255,205,0);
if(m.equals("7")) fill(0,255,102);
if(m.equals("8")) fill(051,051,204);
if(m.equals("9")) fill(051,0,153);
if(m.equals("10")) fill(153,0,153);
if(m.equals("11")) fill(255);
}
}

void keyPressed(){
x = key-'0'*10;
y= key-'0'*10;
}
``` 


##### 코드에 대해 설명하자면, ``` void setup``` 에서는 ``` import processing.net.*;``` 을 사용하여, 클라이언트와 서버 간의 통신이 가능하도록 만듭니다. ```Server```와 ```Client```를 생성하여 s라는 이름을 가지는 ```Server 객체```와 ```c라는 이름을 가지는 Client 객체```를 만듭니다.  사용자의 ip와, 포트번호를 제공받습니다. 추가적으로, 프로세싱 실행화면의 크기를 가로 600, 세로 600으로 조정해주기 위하여 ```size(600,600)```을 사용했습니다.  
##### 배경을 지정하기 위해```PImage img```를 사용하였습니다. ```Img= loadImage(“rainbow.png”);``` 는 사용자의 컴퓨터에 저장된 사진을 불러오도록 합니다.  ```void draw ```안에서 ```image(img, 300, 300, width, height);``` 로 x와 y가 300,300인 위치에 width, height 크기만큼의 사진을 로드합니다.  
##### ```void draw```안에는 계속 반복되는 코드를 작성합니다. 어떠한 데이터가 와이파이를 통하여 들어와서, 그에 맞는 실행이 끝나면 또 다시 데이터를 받아야 합니다. 그렇기 때문에 클라이언트 객체 c는 void draw 영역에서 사용됩니다.``` c=available();```에서 ```available()```은 새로운 메시지를 받아서 반환합니다.   
 #####  이렇게 반환된 데이터는 후에 나올``` c.readString();```을 사용하여 저장된 값을 다른 에 넘겨줄 수 있습니다. 만약 c가 null이 아니면, 즉 c에 값이 들어 있다면 문자열 변수 m을 선언하고,``` c.readString();```을 사용하여 받아온 데이터의 값을 m에 저장합니다.  이때, ```m=m.substring(length()-1);```을 이용하면 m이 받아오는 불필요한 데이터를 자를 수 있습니다. 이제 받아온 데이터의 값에 따라서 특정한 실행을 하도록 코딩해주어야 합니다.   
 ##### 그 전에, 명령에 따라 행동 할 원이 필요합니다. ```if(c!=null)```앞에 ```ellipse(a,b,80,80); ```으로 가로, 세로의 길이가 80인 원을 만듭니다. a와 b는 원의 움직임을 제어하기 위해 정수형 변수로 나타냅니다. a와 b를 사용하기 위해서는 전역변수로써 선언해주어야 합니다. if문을 사용하여``` if(m.equals(“0”)) ```m이 0과 같으면, b=b-30; 즉, y좌표축에 속하는 b의 값에 30만큼 감소합니다. 이렇게한다면, 위로 30만큼 이동하게 됩니다. 또한, if문을 추가해, 공이 실행화면의 바깥으로 넘어가면 a와 b를 처음 위치인 (0,0)으로 이동하도록 코딩하였습니다. ```if(m.equals(“1”))``` 즉 프로세싱에 1이라는 데이터가 들어온다면 b의 값을 30만큼 추가합니다. 이렇게 하면 아래로 30만큼 이동하게 됩니다.  
#####  마찬가지로 if문을 추가하여 원이 바깥으로 넘어가면 원래 좌표로 돌아가도록 합니다. 2와 3의 데이터가 들어와도 위와 같이 작동합니다. 바뀌는 점은 b를 a로 교체하여, x좌표축으로 이동한다는 점 정도가 되겠습니다.  
##### 추가적으로, 사용자의 키보드로 받은 값에 따라서 한 번에 이동하는 거리가 늘어나도록 하였습니다.``` void keyPressed()```에서 x와 y를 추가하고, 전역변수로 선언하였습니다.  
#####  x와 y는 각각 0부터 9까지의 값을 가지고, 입력된 값의 10배를 하여 원의 좌표인 a와 b에 추가해줍니다. 만약 사용자가 키보드를 사용하지 않으면 원의 좌표는 원래 정해진 값인 30씩 이동하고, 키보드로 값을 지정한다면, 그 값의 10배+30 만큼 이동할 것입니다.  
##### 마지막으로, 프로세싱에 4부터 11까지의 숫자 중 특정한 데이터가 들어오면, fill()을 이용하여 공의 색이 바뀌도록 합니다. 4부터 11까지 각각 다른 색깔을 설정하였고, 순서대로 쓰자면 빨, 주, 노, 초, 파, 남, 보, 흰색으로 설정하였습니다.   


--------------------
### 4. 실험 및 고찰
아래는 앱의 화면입니다.  
원이 움직이도록 하는 방향키와 색을 변화시키는 색깔 버튼이 있습니다.   
앱 인벤터의 버튼을 이용하여 (0,0)에 있던 원을 이동하고, 빨간색 버튼과 초록색 버튼을 눌렀을 시 프로세싱 화면입니다. 저희가 처음 구상한 것처럼 상,하,좌,우 버튼을 누르면 공이 이동하고 색깔버튼을 누르면 그 색깔에 맞게 공의 색상이 변화하였습니다. 다만, 키보드로 공의 이동거리를 조절하는 것은 8이나 9와 같은 큰 값으로 설정하면 한 번에 너무 많은 거리를 이동하는 문제를 발견했습니다. 이러한 문제를 해결하기 위해서는 변수 x에 곱하는 값을 조정하거나, 배경의 크기인 size를 조정하는 등, 약간의 코드변형이 필요하다고 생각했습니다. 

--------------------
### 5. 결론
와이파이를 통해 앱 인벤터와 프로세싱 간의 연결을 실습해 보았습니다.   
저희가 만든 프로세싱과 앱인벤터를 더 변형하고, 그래픽적인 부분을 크게 향상시키면 슈퍼마리오 같은 게임을 만들 수 있을 것이라 생각합니다. 움직이는 공 대신 캐릭터를 씌우고, 중력가속도를 추가하여 밑으로 떨어지는 것을 구현하면 실제 게임과 같은 모션을 구현할 수 있다고 생각합니다. 단, 이번에는 앱 인벤터의 상, 하, 좌, 우를 한 번 터치했을 때 일정 거리만큼 건너 뛰도록 만들었습니다. 위에 제시한 것에는 버튼을 누르고 있으면 계속 이동하도록 코딩하여야 합니다. 저희가 앱 인벤터와 프로세싱에 아직 미숙한 부분이 있어, 이러한 부분을 구현하지 못하였지만, 이번에 만든 프로그램을 통하여 구상하고, 구현하는 동안에 얻은 아이디어들은 이 과제가 끝나도 계속 남아있을 것입니다. 또한, 아직 구현하지 못한 아이디어들은 저희가 그래픽스를 배움에 있어서 많은 동기를 부여하고 있다고 장담할 수 있습니다. 


--------------------

### 6. 참고자료

그래픽스카페와 교수님께 배운 강의 내용을 참고하였습니다.   
참고링크: https://cafe.naver.com/graphicscafe

--------------------
### 7. 팀워크를 어떻게 하였는가?  

현재 코로나 바이러스가 확산됨에 있어서 비대면 수업을 하게 됨에 따라, 안동이 아닌 각자의 지역에 살고있어, 만나기는 힘들것이라 판단하였습니다. 주된 의사소통 매체는 카카오톡 메시지였고, 카카오톡 메시지로 아이디어 회의와 구상을 하고, 코드와 앱 인벤터 구현은 크롬이 제공하는 화상통화 시스템인 행아웃을 이용하였습니다. 행아웃은 자신의 컴퓨터 화면을 같은 방에 있는 사람들에게 보여줄 수 있는 화면공유 시스템이 탑재되어 있어, 그것을 이용하여 프로세싱으로 코드는 어떻게 짰는지, 앱 인벤터는 어떻게 설계했는지 서로 보여주면서 과제를 진행했습니다. 카카오톡으로 그저 자신이 짠 코드를 보내주는 것보다, 행아웃을 이용하여 실시간으로 서로 진행도를 보여주고, 틀린 부분을 혼자가 아닌, 함께 고칠 수 있어서 팀의 협업은 물론, 혼자하는 것보다 효율이 더 좋았다고 생각합니다. 

--------------------
### 8. 소감
 앱 인벤터와 프로세싱 모두 작년 창의공학때 사용해 본 경험이 있습니다. 하지만 창의공학때는 주로 아두이노, A봇, 앱인벤터와 프로세싱 네 가지를 이용하여, 아두이노와 A봇의 움직임을 보았습니다. 이번 과제처럼 프로세싱과 앱인벤터 만으로 어떤 프로그램을 만드는 것은 처음이었기에 매우 흥미로웠습니다. 또 프로세싱과 앱인벤터으로만 만든 프로그램은 직관성이 좋기 때문에, 많은 아이디어가 제시되었습니다. 하지만 프로세싱에 대한 지식은 어느정도 있는 반면에, 앱 인벤터는 저희 둘 다 무지한 상태였습니다. 처음에는 가속도 센서를 사용하여 스마트폰을 기울이면, 그 기울기를 읽어서 프로세싱에 보내고, 그 값을 프로세싱이 인식하여 공이 스마트폰이 기울어진 방향과 같은 방향으로 이동하도록 하는 프로그램을 만들고 싶었습니다. 하지만 앱 인벤터의 방향센서를 사용하는 것과, 프로세싱을 어떻게 코딩해야 할 지, 마땅히 좋은 아이디어가 없어서 다른 것을 고민하게 되었습니다. 그렇게 구상된 것이 저희의 원을 변화시키는 스마트폰 앱입니다. 각자 생각한 것을 잘 조합하다 보니 굉장히 빠른 시간내에 주제를 정할 수 있었고, 프로세싱으로 코드를 짜고, 앱 인벤터로 블록을 설계하는 것 역시 함께 협업하니 혼자하는 것보다 더 빨리 끝낼 수 있었습니다. 함께 고민하며 프로그램을 완성시키고, 완성품을 테스트 해 볼 때 정말 뿌듯했습니다. 혼자서 이러한 아이디어를 기획해 낼 수 있었을지, 코드를 제대로 짤 수 있었을 지 상상조차 되지 않습니다. 함께 했기에 완성할 수 있었고, 그만큼 더 기쁜 것이라 생각합니다. 계속 증진하여 구글스토어에 등록된 수많은 앱 중에서 저희가 만든 앱도 리스트에 올라갈 수 있을 정도로 실력을 기르도록 하겠습니다.
